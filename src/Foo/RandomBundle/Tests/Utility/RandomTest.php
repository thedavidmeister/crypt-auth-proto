<?php

namespace Foo\RandomBundle\Tests\Utility;

use Foo\RandomBundle\Utility\Random;
use Symfony\Component\Validator\Validation;
use Symfony\Component\Validator\ConstraintViolation;
use Symfony\Component\Validator\ConstraintViolationList;

class RandomTest extends \PHPUnit_Framework_TestCase
{
  /**
   * Size of data set.
   *
   * This is a random number generator, so we can't test it "completely", all
   * we can do is attempt to get a representative sample of the data it
   * produces.
   *
   * @var integer
   */
  const ROUNDS = 1000;

  /**
   * The number of bytes that random integers must be.
   *
   * @var integer
   */
  const INT_BYTES = 8;

  /**
   * The minimum bytes the rng can produce in generate().
   *
   * @var integer
   */
  const MIN_BYTES = 1;

  /**
   * The maximum bytes the rng can produce in generate().
   * @var integer
   */
  const MAX_BYTES = 1024;

  /**
   * Returns a mock validator.
   */
  private function getMockValidator()
  {
    return $this->getMockBuilder('\Symfony\Component\Validator\ValidatorInterface')->getMock();
  }

  /**
   * Returns the default Symfony validator.
   */
  private function getValidator()
  {
    return Validation::createValidatorBuilder()->enableAnnotationMapping()->getValidator();
  }

  /**
   * Returns a dummy validator.
   *
   * @return \Symfony\Component\Validator\ValidatorInterface
   */
  private function getValidatorDummy()
  {
    $mock = $this->getMockValidator();

    $mock
      ->expects($this->atLeastOnce())
      ->method('validate');

    return $mock;
  }

  /**
   * Returns a ConstraintViolationList with a single ConstraintViolation.
   *
   * @see \Symfony\Component\Validator\Tests
   */
  private function getViolatedConstraintViolationList()
  {
    $message = 'some violation';
    $violation = new ConstraintViolation($message, $message, array(), null, null, null);
    return new ConstraintViolationList(array($violation));
  }

  /**
   * Returns a stub validator object that always fails validation.
   *
   * @return \Symfony\Component\Validator\ValidatorInterface
   */
  private function getValidatorStubFail() {
    $mock = $this->getMockValidator();

    $mock
      ->expects($this->atLeastOnce())
      ->method('validate')
      ->will($this->returnValue($this->getViolatedConstraintViolationList()));

    return $mock;
  }

  /**
   * Generates an array of $this->rounds random values using generateValue().
   *
   * @return array
   *   An array of length $this->rounds of randomly generated data.
   */
  private function getData($method, $bytes = null)
  {
    // Build $this->rounds of random data.
    $i = 0;
    $data = array();
    while ($i < $this::ROUNDS) {
      $data[] = $this->generateValue($method, $bytes);
      $i++;
    }

    return $data;
  }

  /**
   * Generates a single random value.
   *
   * @param string $method
   *   The public method of Random to call to generate values.
   *
   * @param null|int
   *   The number of bytes of data to generate. If not set, a random number of
   *   bytes between MIN_BYTES and MAX_BYTES will be set.
   *
   * @return mixed
   *   Random data, as per $method.
   */
  private function generateValue($method, $bytes = null)
  {
    // We don't need real validation to generate the data so just use a dummy.
    $random = new Random($this->getValidatorDummy());

    $bytes = isset($bytes) ? $bytes : rand($this::MIN_BYTES, $this::MAX_BYTES);

    $random->setBytes($bytes);

    return $random->{$method}();
  }

  /**
   * Test that Random::integer() returns valid integers.
   */
  public function testInteger()
  {
    // Generate integer data.
    $data = $this->getData('integer', $this::INT_BYTES);

    // Integer data should all be native PHP integer type.
    $this->assertContainsOnly('integer', $data);

    // While it is *possible* that the integer 0 is legitimately generated in a
    // small test run (small relative to PHP_INT_MAX) it is much, much more
    // likely that seeing exactly 0 means "infinity" was generated by the system
    // trying to convert more bits than it can internally represent
    // (usually either 32 or 64) and then casting "infinity" to an integer,
    // which results in 0. Similarly, seeing the upper bounds in the data
    // probably means there's something bad going on.
    $this->assertNotContains(0, $data);
    $this->assertNotContains(PHP_INT_MAX, $data);
  }

  /**
   * Test that Random::normalized() produces floats roughly as expected.
   */
  public function testNormalized()
  {
    // Generate normalized data.
    $data = $this->getData('normalized', $this::INT_BYTES);

    // Normalized data should all be native PHP float type.
    $this->assertContainsOnly('float', $data);

    // Normalized data should be between 0 and 1.
    $this->assertLessThanOrEqual(1, max($data));
    $this->assertGreaterThanOrEqual(0, min($data));

    // The average of normalized data should be about 0.5 and we should have
    // roughly the same number of values between 0 - 0.5 and 0.5 - 1.
    // This is nowhere near a substitute for statistical tests for "randomness"
    // (we have to rely on /dev/urandom working as advertised) but we try to
    // raise red flags if something appears to be seriously wrong with our PHP
    // wrapper that is leading to obviously skewed data.
    $average = array_reduce($data, function($carry, $item) { return $carry + $item; }, 0) / count($data);
    $delta = abs(0.5 - $average);
    // 5% tolerance on the mean seems about right for 1000 rounds. Feel free to
    // change this if it causes regular issues for testbots or base it on some
    // non-empirical, actual math.
    $tolerance = 0.05;
    $this->assertLessThanOrEqual($tolerance, $delta);

    // Number of values between 0 - 0.5.
    $zero_to_half = array_filter($data, function($item) {
      return $item < 0.5;
    });

    // Number of values between 0.5 - 1.
    $half_to_one = array_filter($data, function($item) {
      return $item > 0.5;
    });

    // Difference in size of the two ranges.
    $delta = abs(count($zero_to_half) - count($half_to_one));

    // 100 tolerance seems about right for 1000 rounds, values of 10-70 are
    // common. Feel free to base this on non-empirical, actual math.
    $tolerance = 100;
    $this->assertLessThanOrEqual($tolerance, $delta);

    // For the same reasons as in testInteger, we don't want to see the bounds
    // showing up in our data. These values ARE technically valid data points,
    // but because they're both so unlikely to show up (and could become likely
    // due to bad PHP code) we might as well assert that they don't exist, as a
    // starting point for future investigations.
    $this->assertNotContains((float) 0, $data);
    $this->assertNotContains((float) 1, $data);
  }

  /**
   * Test that Random::hex() produces random hexadecimal encoded bytes.
   */
  public function testHexadecimal()
  {
    // Generate hex data with random length.
    $method = 'hex';
    $data = $this->getData($method);

    // Hex data should all be PHP strings.
    $this->assertContainsOnly('string', $data);

    // Check that all generated data represents hex digits.
    foreach ($data as $datum) {
      $this->assertTrue(ctype_xdigit($datum));
    }

    // Check that the correct bytes of data is produced.
    $i = $this::MIN_BYTES;
    while ($i <= $this::MAX_BYTES) {
      $value = $this->generateValue($method, $i);
      $value_bytes = strlen($value) / 2;
      $this->assertEquals($i, $value_bytes);
      $i++;
    }
  }

  /**
   * Test that Random::base64() produces random base64 encoded bytes.
   */
  public function testBase64()
  {
    // Generate base64 data with random length.
    $method = 'base64';
    $data = $this->getData($method);

    // Base64 ata should all be PHP strings.
    $this->assertContainsOnly('string', $data);

    // Check that all generated strings are valid base64 encodings.
    foreach ($data as $datum) {
      // http://stackoverflow.com/questions/4278106/how-to-check-if-a-string-is-base64-valid-in-php
      $encodable = base64_encode(base64_decode($datum, true)) === $datum;
      $this->assertTrue($encodable);
    }

    // Check that the correct bytes of data is produced.
    $i = $this::MIN_BYTES;
    while ($i <= $this::MAX_BYTES) {
      $value = $this->generateValue($method, $i);
      $value_bytes = strlen(base64_decode($value));
      $this->assertEquals($i, $value_bytes);
      $i++;
    }
  }

  /**
   * Tests that an exception is thrown if validation fails for any reason.
   *
   * @expectedException Exception
   */
  public function testValidationException()
  {
    $random = new Random($this->getValidatorStubFail());

    $random->validate();
  }

  /**
   * Basic tests for the default state of Random.
   */
  public function testValidationDefaults()
  {
    $random = new Random($this->getValidator());

    // Check that the default bytes are set correctly.
    $this->assertEquals($random::DEFAULT_BYTES, strlen($random->hex()) / 2);

    // Generate one of each set of data using defaults, this should not trigger
    // exceptions.
    $methods = $random->getMethods();
    foreach ($methods as $method) {
      $random = new Random($this->getValidator());
      $random->{$method}();
    }
  }

  /**
   * Tests that an exception is thrown when $bytes exceeds upper bounds.
   *
   * @expectedException Exception
   */
  public function testValidationBytesUpperBounds()
  {
    $random = new Random($this->getValidator());

    $random->setBytes($this::MAX_BYTES + 1);

    $random->validate();
  }

  /**
   * Tests that an exception is thrown when $bytes exceeds lower bounds.
   *
   * @expectedException Exception
   */
  public function testValidationBytesLowerBounds()
  {
    $random = new Random($this->getValidator());

    $random->setBytes($this::MIN_BYTES - 1);

    $random->validate();
  }

  /**
   * Tests that the getMethods() and getIntMethods() return the correct arrays.
   */
  public function testMethodsArrays() {
    $random = new Random($this->getValidatorDummy());

    $methods = array(
      'integer',
      'normalized',
      'hex',
      'base64',
    );
    $this->assertEquals($methods, $random->getMethods());

    $int_methods = array(
      'integer',
      'normalized',
    );
    $this->assertEquals($int_methods, $random->getIntMethods());

    // This is a hack because I'm lazy, it just stops the dummy validator from
    // complaining that we did not call validate() at least once.
    $random->validate();
  }

}
